class t{run(){if(this.running)return;this.running=!0,console.log("%c%s","color: #1abc9c; font-weight: bold","Made with bottlecap.js"),this.init(),this._lastStep=performance.now();const t=()=>{this.step(),this._lastStep=performance.now(),this._frameRequest=requestAnimationFrame(t)};requestAnimationFrame(t)}stop(){this._frameRequest&&cancelAnimationFrame(this._frameRequest),this._frameRequest=null,this.running=!1}step(){const t=performance.now(),e=(t-this._lastStep)/1e3;this._lastStep=t,this.update(e),this.render()}init(){console.log("Game Initialized")}update(t){}render(){}}const e=Math.PI,s=2*e,i=e/2,r=(t,e,s,i)=>{const r=t-s,a=e-i;return Math.sqrt(r*r+a*a)};var a=Object.freeze({__proto__:null,PI:e,TWO_PI:s,HALF_PI:i,pointDistance:r,pointToAngle:(t,e)=>-Math.atan2(-e,t),clamp:(t,e,s)=>Math.max(e,Math.min(t,s))});class n{constructor(t=0,e=0){this.x=t,this.y=e}static zero(){return new n}static create(t,e){return new n(t,e)}static clone({x:t,y:e}){return n.create(t,e)}static copy(t,e){return Object.assign(t,e)}static set(t,e,s){return t.x=null!=e?e:t.x,t.y=null!=s?s:t.y,t}static add(t,{x:e,y:s}){return t.x+=e,t.y+=s,t}static sub(t,{x:e,y:s}){return t.x-=e,t.y-=s,t}static mul(t,{x:e,y:s}){return t.x*=e,t.y*=s,t}static div(t,{x:e,y:s}){return t.x/=e,t.y/=s,t}static addScalar(t,e){return t.x+=e,t.y+=e,t}static subScalar(t,e){return t.x-=e,t.y-=e,t}static mulScalar(t,e){return t.x*=e,t.y*=e,t}static divScalar(t,e){return t.x/=e,t.y/=e,t}static angle(t){return Math.atan2(-t.y,-t.x)+PI}static calcLength(t){return Math.sqrt(t.x*t.x+t.y*t.y)}static equals(t,e){return t.x===e.x&&t.y===e.y}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return t.x*e.y-t.y*e.x}static lerp(t,{x:e,y:s},i){return t.x+=(e-t.x)*i,t.y+=(s-t.y)*i,t}static normalize(t){return n.divScalar(t,n.calcLength(t)||1),t}static distance(t,e){return r(t.x,t.y,e.x,e.y)}}const o=Math.round;class c{constructor(t,e=0,s=0,i=0,r=0){this.ctx=t,this.pos=n.create(e,s),this.target=n.zero(),this.cx=o(t.canvas.width/2)-i,this.cy=o(t.canvas.height/2)-r}attach(){this.ctx.save(),this.ctx.translate(this.pos.x,this.pos.y)}detach(){this.ctx.restore()}update(t){n.set(this.pos,this.cx-this.target.x,this.cy-this.target.y)}lookAt(t,e){n.set(this.target,t,e)}}class h{constructor(){this.topics={}}emit(t,...e){const s=this.topics[t];!s||s.size<0||s.forEach((t=>t(...e)))}hasTopic(t){return Reflect.has(this.topics,t)}on(t,e){return this.hasTopic(t)||(this.topics[t]=new Set),this.topics[t].add(e),()=>this.off(t,e)}once(t,e){const s=(...i)=>{this.off(t,s),e(...i)};return this.on(t,s)}off(t,e){this.hasTopic(t)&&this.topics[t].delete(e)}destroy(){this.topics={}}}const u=document,l=/([.#])/,d=t=>{const e=t.split(l);let s="",i="";for(let t=1;t<e.length;t+=2)switch(e[t]){case".":i+=` ${e[t+1]}`;break;case"#":s=e[t+1]}return{tag:e[0]||"div",className:i.trim(),id:s}},m=(t,e,s)=>{if(void 0===s)return t.getAttribute(e);!1===s?t.removeAttribute(e):t.setAttribute(e,s)},p=(t,e,s)=>t.addEventListener(e,s,!1),x=(t,e,s)=>t.removeEventListener(e,s,!1);var y=Object.freeze({__proto__:null,el:t=>{const{tag:e,id:s,className:i}=d(t),r=u.createElement(e);return s&&(r.id=s),i&&(r.className=i),r},svg:t=>{const{tag:e,id:s,className:i}=d(t),r=u.createElementNS("http://www.w3.org/2000/svg",e);return s&&(r.id=s),i&&m(r,"class",i),r},frag:()=>u.createDocumentFragment(),text:(t="")=>u.createTextNode(t),qs:(t,e=u)=>e.querySelector(t),qsa:(t,e=u)=>e.querySelectorAll(t),setStyle:(t,e)=>Object.assign(t.style,e),attr:m,on:p,off:x,ready:t=>{/complete|loaded|interactive/.test(u.readyState)&&u.body?setTimeout(t,1):p(u,"DOMContentLoaded",t)}});const f=n.zero(),g={};class w{static keyDown(t){return!!g[t]}static getDirection(){const t=w.keyDown,e=w.KEYS,s=t(e.LEFT)?-1:t(e.RIGHT)?1:0,i=t(e.UP)?-1:t(e.DOWN)?1:0;return n.set(f,s,i),f}static KEYS={LEFT:"ArrowLeft",RIGHT:"ArrowRight",UP:"ArrowUp",DOWN:"ArrowDown",SPACEBAR:" ",ESCAPE:"Escape",ENTER:"Enter",CTRL:"Control",TAB:"Tab",ALT:"Alt",W:"w",A:"a",S:"s",D:"d",E:"e",X:"x",Z:"z"}}p(window,"keydown",(t=>{t.defaultPrevented||(g[t.key]=!0,t.preventDefault())})),p(window,"keyup",(t=>g[t.key]=!1));class A{static isTouchscreen(){return!!("ontouchstart"in document.documentElement)}static gamepadAvailable(){return!(!navigator||!navigator.getGamepads)}}const S=Math.abs,E={TOP:"top",BOTTOM:"bottom",LEFT:"left",RIGHT:"right"};class v{static circleInCircle(t,e,s,i,a,n){return r(t,e,i,a)<=s+n}static pointInCircle(t,e,s,i,a){return r(t,e,s,i)<=a}static rectInRect(t,e,s,i,r,a,n,o){return t<r+n&&t+s>r&&e<a+o&&e+i>a}static pointInRect(t,e,s,i,r,a){return s<=t&&t<=s+r&&i<=e&&e<=i+a}static circleInRect(t,e,s,i,r,a,n){const o=a/2,c=n/2,h=S(t-i-o),u=S(e-r-c);if(h>o+s)return!1;if(u>c+s)return!1;if(h<=o)return!0;if(u<=c)return!0;const l=h-o,d=u-c;return l*l+d*d<=s*s}static resolveCollision(t,e){const s=t.position.x+t.size.x/2-(e.position.x+e.size.x/2),i=t.position.y+t.size.y/2-(e.position.y+e.size.y/2),r=t.size.x/2+e.size.x/2,a=t.size.y/2+e.size.y/2;let n="";if(S(s)<r&&S(i)<a){const e=r-S(s),o=a-S(i);e>=o?i>0?(n=E.TOP,t.position.y+=o):(n=E.BOTTOM,t.position.y-=o):s>0?(n=E.LEFT,t.position.x+=e):(n=E.RIGHT,t.position.x-=e)}return n}}let z=null;const O=()=>(z||(z=new AudioContext),z);let T=null;const M=()=>{if(!T){const t=O();T=t.createGain(),T.connect(t.destination)}return T};class I{static play(t,e,s=0,i=!1){const r=O().createBufferSource();return r.buffer=e,r.connect(t||M()),r.loop=i,r.start(s),r}static stop(t,e=0){t.stop(e)}static setVolume(t,e){(t||M()).gain.value=e}}const q=()=>{const t=O();/interrupted|suspended/.test(t.state)&&t.resume(),x(window,"click",q)};p(window,"click",q);const b={IMAGE:"image",SOUND:"sound",JSON:"json"},N=(t,{name:e,type:s,value:i})=>(t[s]||(t[s]={}),t[s][e]=i,t);class _{static Image(t,e){return new Promise(((s,i)=>{const r=new Image;r.crossOrigin="Anonymous",r.onload=()=>s({type:b.IMAGE,name:t,value:r}),r.onerror=()=>i(new Error(`Couldn't load Image: ${e}`)),r.src=e}))}static async Sound(t,e){const s=O(),i=await fetch(e);if(!i.ok)throw new Error(`Couldn't Load Sound: ${e}`);const r=await i.arrayBuffer(),a=await s.decodeAudioData(r);return{type:b.SOUND,name:t,value:a}}static async JSON(t,e){const s=await fetch(e);if(!s.ok)throw new Error(`Couldn't load the JSON file: ${e}`);const i=await s.json();return{type:b.JSON,name:t,value:i}}static async loadAll(t){return(await Promise.all(t)).reduce(N,{})}}const F=({name:t,type:e,src:s})=>{switch(e){case b.IMAGE:return _.Image(t,s);case b.SOUND:return _.Sound(t,s);case b.JSON:return _.JSON(t,s);default:throw new Error(`Unknown Asset Type: "${e}"`)}};class R extends h{constructor(){super(),this.queue=[],this.loading=!1}enqueue(t,e,s){if(this.loading)throw new Error("Can't Enqueue Assets While The Loader is Loading.");this.queue.push({name:t,type:s,src:e})}addImage(t,e){return this.enqueue(t,e,b.IMAGE),this}addSound(t,e){return this.enqueue(t,e,b.SOUND),this}addJSON(t,e){return this.enqueue(t,e,b.JSON),this}clearQueue(){for(;this.queue.length;)this.queue.pop()}reset(){this.clearQueue(),this.loading=!1}async load(){if(this.loading)return void console.error("Loader is already loading.");this.loading=!0;const t=this.queue.map(F);try{const e=await _.loadAll(t);this.emit("load",e)}catch(t){this.emit("error",t)}finally{this.reset()}}}class C{constructor(t,e,s=0,i=0,r,a,o,c,h,u){this.ctx=t,this.image=e,this.sourceX=s,this.sourceY=i,this.sourceWidth=r||this.image.width,this.sourceHeight=a||this.image.height,this.position=n.create(o,c),this.size=n.create(h||this.image.width,u||this.image.height),this.rotation=0,this.flipX=!1,this.flipY=!1}render(){this.ctx.save(),this.ctx.translate(this.position.x+this.size.x/2,this.position.y+this.size.x/2),this.ctx.scale(this.scale,this.scale),this.ctx.rotate(this.rotation),this.ctx.scale(this.flipX?-1:1,this.flipY?-1:1),this.ctx.translate(-(this.position.x+this.size.x/2),-(this.position.y+this.size.x/2)),this.ctx.drawImage(this.image,this.sourceX,this.sourceY,this.sourceWidth,this.sourceHeight,this.position.x,this.position.y,this.size.x,this.size.y),this.ctx.restore()}}class D{constructor(t,e,s,i,r,a,o,c){this.ctx=t,this.spritesheet=e,this.numCol=s,this.numRow=i,this.frameWidth=e.width/s,this.frameHeight=e.height/i,this.position=n.create(r,a),this.size=n.create(o||this.frameWidth,c||this.frameHeight),this.maxFrames=s*i-1,this.currentFrame=0,this.flipX=!1,this.flipY=!1,this.rotation=0,this.scale=1,this.animations=new Map,this.currentAnimation=null,this.playing=!1,this.time=0}addAnimation(t,e,s,i){if(this.animations.has(t))throw new Error(`Animation with name "${t}" already exists.`);const r=new L(this,e,s,i);return this.animations.set(t,r),this}play(t){if(!this.animations.has(t))throw new Error(`Animation with name "${t}" does not exists.`);this.currentAnimation=this.animations.get(t),this.currentFrame=this.currentAnimation.frameStart,this.playing=!0,this.time=0}stop(){this.playing=!1}update(t){if(!this.playing)return;const{frameStart:e,frameEnd:s,delay:i}=this.currentAnimation;this.time>=i&&(this.currentFrame++,this.currentFrame>s&&(this.currentFrame=e),this.time=0),this.time+=t}render(){if(!this.currentAnimation)throw new Error("Can't Render AnimatedSprite. No current animation has been set.");const[t,e]=this.currentAnimation.getFrame(this.currentFrame);this.ctx.save(),this.ctx.translate(this.position.x+this.size.x/2,this.position.y+this.size.x/2),this.ctx.scale(this.scale,this.scale),this.ctx.rotate(this.rotation),this.ctx.scale(this.flipX?-1:1,this.flipY?-1:1),this.ctx.translate(-(this.position.x+this.size.x/2),-(this.position.y+this.size.x/2)),this.ctx.drawImage(this.spritesheet,t*this.frameWidth,e*this.frameHeight,this.frameWidth,this.frameHeight,this.position.x,this.position.y,this.size.x,this.size.y),this.ctx.restore()}}class L{constructor(t,e,s,i=100){this.sprite=t,this.frameStart=e,this.frameEnd=s||this.sprite.maxFrames,this.delay=i/1e3,this.frames=[];for(let t=this.frameStart;t<=this.frameEnd;t++)this.frames[t]=[t%this.sprite.numCol,Math.floor(t/this.sprite.numCol)]}getFrame(t){return this.frames[t]}}const k=n.create();var P=Object.freeze({__proto__:null,getMousePos:(t,e)=>{const s=t.getBoundingClientRect(),i=t.width/s.width,r=t.height/s.height;return n.set(k,(e.clientX-s.left)*i,(e.clientY-s.top)*r),k},random:(t=0,e=1)=>Math.random()*(e-t)+t,randomInt:(t=0,e=1)=>(t=Math.ceil(t),e=Math.floor(e),Math.floor(Math.random()*(e-t+1))+t),unique:t=>[...new Set(t)],shuffle:t=>t.sort((()=>Math.random()-.5)),chunk:(t,e)=>{const s=[];for(let i=0;i<t.length;i+=e)s.push(t.slice(i,i+e));return s}});const G=(t=400,e=400,s)=>{const i=document.createElement("canvas");return i.width=t,i.height=e,s&&(i.style.background=s),i};export{b as ASSET_TYPES,D as AnimatedSprite,E as COLLISION_SIDE,c as Camera,v as Collision,y as DOM,A as Device,h as Emitter,t as Game,a as GameMath,w as Keyboard,R as Loader,_ as ResourceLoader,I as Sound,C as Sprite,L as SpriteAnimation,P as Utils,n as Vec2,G as createCanvas,O as getAudioCtx,M as getSoundMixer};